use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::os::unix::fs::PermissionsExt;
use anyhow::{Context, Result};
use tokio::sync::RwLock;
use crate::language_support::Language;
use crate::enterprise::EnterpriseManager;
use image::{ImageBuffer, Rgb};
use base64::{Engine as _, engine::general_purpose};
use sha2::{Sha256, Digest};
use uuid::Uuid;
use chrono::{DateTime, Utc};

pub struct ProAppImageBuilder {
    project_name: String,
    source_files: HashMap<Language, Vec<PathBuf>>,
    output_dir: PathBuf,
    enterprise_manager: Arc<RwLock<EnterpriseManager>>,
    build_id: String,
    timestamp: DateTime<Utc>,
}

impl ProAppImageBuilder {
    pub fn new(
        project_name: String, 
        source_files: HashMap<Language, Vec<PathBuf>>,
        enterprise_manager: Arc<RwLock<EnterpriseManager>>
    ) -> Self {
        let build_id = Uuid::new_v4().to_string();
        let timestamp = Utc::now();
        let output_dir = PathBuf::from(format!("./{}_pro_appimage", project_name));
        
        Self {
            project_name,
            source_files,
            output_dir,
            enterprise_manager,
            build_id,
            timestamp,
        }
    }

    pub async fn build_professional(&self) -> Result<PathBuf> {
        println!("üèóÔ∏è  Creating Professional AppImage Structure...");
        
        // Create output directory structure
        self.create_professional_directory_structure()?;
        
        // Consolidate source files with professional formatting
        let consolidated_file = self.consolidate_source_files_professionally()?;
        
        // Create professional AppImage structure
        self.create_professional_appimage_structure(&consolidated_file)?;
        
        // Generate professional icon
        self.generate_professional_icon()?;
        
        // Create the professional AppImage
        let appimage_path = self.create_professional_appimage().await?;
        
        // Generate build report
        self.generate_build_report(&appimage_path).await?;
        
        Ok(appimage_path)
    }

    fn create_professional_directory_structure(&self) -> Result<()> {
        // Create main output directory
        fs::create_dir_all(&self.output_dir)?;
        
        // Create AppDir structure with professional layout
        let appdir = self.output_dir.join("AppDir");
        fs::create_dir_all(&appdir)?;
        
        // Create standard AppImage directories
        fs::create_dir_all(appdir.join("usr").join("bin"))?;
        fs::create_dir_all(appdir.join("usr").join("share").join("applications"))?;
        fs::create_dir_all(appdir.join("usr").join("share").join("icons").join("hicolor").join("256x256").join("apps"))?;
        fs::create_dir_all(appdir.join("usr").join("share").join("doc").join(&self.project_name))?;
        fs::create_dir_all(appdir.join("usr").join("share").join("metainfo"))?;
        
        Ok(())
    }

    fn consolidate_source_files_professionally(&self) -> Result<PathBuf> {
        let consolidated_path = self.output_dir.join("AppDir").join("usr").join("bin").join(format!("{}.py", self.project_name));
        
        let mut consolidated_content = String::new();
        consolidated_content.push_str(&format!("# {} - Professional Consolidated Source Code\n", self.project_name));
        consolidated_content.push_str("# Generated by LOL PRO - Professional Multi-language Code Compiler\n");
        consolidated_content.push_str(&format!("# Build ID: {}\n", self.build_id));
        consolidated_content.push_str(&format!("# Timestamp: {}\n", self.timestamp.format("%Y-%m-%d %H:%M:%S UTC")));
        consolidated_content.push_str("# Enterprise Features: ACTIVATED\n\n");
        
        // Add Python shebang and professional imports
        consolidated_content.push_str("#!/usr/bin/env python3\n");
        consolidated_content.push_str("# -*- coding: utf-8 -*-\n");
        consolidated_content.push_str("import os\nimport sys\nimport subprocess\nimport tempfile\nimport json\nimport hashlib\nfrom pathlib import Path\n\n");
        
        // Add professional main function
        consolidated_content.push_str("def main():\n");
        consolidated_content.push_str(&format!("    print('üöÄ {} - Professional Multi-language Project')\n", self.project_name));
        consolidated_content.push_str("    print('üè¢ Enterprise Edition - Built with LOL PRO')\n");
        consolidated_content.push_str(&format!("    print('üîí Build ID: {}')\n", self.build_id));
        consolidated_content.push_str("    print('üìÅ Source files consolidated into this AppImage\\n')\n\n");
        
        // Add source code from each language with professional formatting
        for (language, files) in &self.source_files {
            consolidated_content.push_str(&format!("    # {} Source Files - Professional Analysis\n", language.name()));
            consolidated_content.push_str(&format!("    print('üìã {} files:')\n", language.name()));
            
            for file in files {
                if let Ok(content) = fs::read_to_string(file) {
                    let filename = file.file_name().unwrap().to_string_lossy();
                    let lines = content.lines().count();
                    let size = content.len();
                    let hash = self.calculate_file_hash(&content);
                    
                    consolidated_content.push_str(&format!("    print('  - {} ({} lines, {} bytes, hash: {})')\n", 
                        filename, lines, size, hash));
                    
                    // Store the source code as a string in the consolidated file
                    consolidated_content.push_str(&format!("    {}_code = '''{}\n'''\n", 
                        filename.replace(".", "_").replace("-", "_"), content));
                    
                    // Store metadata
                    consolidated_content.push_str(&format!("    {}_metadata = {{\n", filename.replace(".", "_").replace("-", "_")));
                    consolidated_content.push_str(&format!("        'filename': '{}',\n", filename));
                    consolidated_content.push_str(&format!("        'language': '{}',\n", language.name()));
                    consolidated_content.push_str(&format!("        'lines': {},\n", lines));
                    consolidated_content.push_str(&format!("        'size': {},\n", size));
                    consolidated_content.push_str(&format!("        'hash': '{}',\n", hash));
                    consolidated_content.push_str("    }\n\n");
                }
            }
            consolidated_content.push_str("\n");
        }
        
        // Add professional execution logic
        consolidated_content.push_str("    # Professional execution with error handling\n");
        consolidated_content.push_str("    try:\n");
        consolidated_content.push_str("        print('üîç Analyzing project structure...')\n");
        consolidated_content.push_str("        \n");
        consolidated_content.push_str("        # Try to run Python files first\n");
        consolidated_content.push_str("        python_files = [f for f in os.listdir('.') if f.endswith('.py')]\n");
        consolidated_content.push_str("        if python_files:\n");
        consolidated_content.push_str("            main_file = python_files[0]\n");
        consolidated_content.push_str("            print(f'üêç Executing {main_file}...')\n");
        consolidated_content.push_str("            result = subprocess.run([sys.executable, main_file], capture_output=True, text=True)\n");
        consolidated_content.push_str("            if result.returncode == 0:\n");
        consolidated_content.push_str("                print('‚úÖ Execution successful')\n");
        consolidated_content.push_str("                if result.stdout:\n");
        consolidated_content.push_str("                    print('Output:', result.stdout)\n");
        consolidated_content.push_str("            else:\n");
        consolidated_content.push_str("                print(f'‚ùå Execution failed: {result.stderr}')\n");
        consolidated_content.push_str("        else:\n");
        consolidated_content.push_str("            print('No Python files found to execute')\n");
        consolidated_content.push_str("            \n");
        consolidated_content.push_str("        # Display project statistics\n");
        consolidated_content.push_str("        print('\\nüìä Project Statistics:')\n");
        consolidated_content.push_str(&format!("        print('  - Total files: {}')\n", self.source_files.values().map(|v| v.len()).sum::<usize>()));
        consolidated_content.push_str("        print('  - Build ID:', build_id)\n");
        consolidated_content.push_str("        print('  - Enterprise Features: ACTIVE')\n");
        consolidated_content.push_str("        \n");
        consolidated_content.push_str("    except Exception as e:\n");
        consolidated_content.push_str("        print(f'‚ùå Error executing project: {e}')\n");
        consolidated_content.push_str("        print('üí° You can extract and compile the source files manually')\n");
        consolidated_content.push_str("        print('üîí Enterprise support available at: https://lol-compiler.com/support')\n\n");
        
        consolidated_content.push_str("if __name__ == '__main__':\n");
        consolidated_content.push_str("    main()\n");
        
        fs::write(&consolidated_path, consolidated_content)?;
        
        // Make it executable
        let mut perms = fs::metadata(&consolidated_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&consolidated_path, perms)?;
        
        Ok(consolidated_path)
    }

    fn calculate_file_hash(&self, content: &str) -> String {
        let mut hasher = Sha256::new();
        hasher.update(content.as_bytes());
        let result = hasher.finalize();
        format!("{:x}", result)[..8].to_string()
    }

    fn create_professional_appimage_structure(&self, _consolidated_file: &Path) -> Result<()> {
        let appdir = self.output_dir.join("AppDir");
        
        // Create professional desktop entry
        let desktop_content = format!(
            "[Desktop Entry]\n\
            Name={} Pro\n\
            Comment=Professional multi-language project generated by LOL PRO\n\
            Exec={}\n\
            Icon={}\n\
            Terminal=true\n\
            Type=Application\n\
            Categories=Development;IDE;\n\
            Keywords=development;programming;multi-language;professional\n\
            Version=1.0\n\
            GenericName=Professional Code Project\n",
            self.project_name,
            format!("{}.py", self.project_name),
            self.project_name
        );
        
        fs::write(
            appdir.join("usr").join("share").join("applications").join(format!("{}.desktop", self.project_name)),
            desktop_content
        )?;
        
        // Create AppStream metadata
        let appstream_content = format!(
            "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\
            <component type=\"desktop-application\">\n\
              <id>{}</id>\n\
              <name>{}</name>\n\
              <summary>Professional Multi-language Project</summary>\n\
              <description>\n\
                <p>Professional multi-language project generated by LOL PRO - Enterprise Edition.</p>\n\
                <p>This AppImage contains consolidated source code from multiple programming languages.</p>\n\
              </description>\n\
              <url type=\"homepage\">https://lol-compiler.com</url>\n\
              <url type=\"help\">https://docs.lol-compiler.com</url>\n\
              <launchable type=\"desktop-id\">{}.desktop</launchable>\n\
              <metadata_license>Commercial</metadata_license>\n\
              <project_license>Commercial</project_license>\n\
              <content_rating type=\"oars-1.1\">\n\
                <content_attribute id=\"violence-cartoon\">none</content_attribute>\n\
                <content_attribute id=\"violence-fantasy\">none</content_attribute>\n\
                <content_attribute id=\"violence-realistic\">none</content_attribute>\n\
                <content_attribute id=\"violence-bloodshed\">none</content_attribute>\n\
                <content_attribute id=\"violence-sexual\">none</content_attribute>\n\
                <content_attribute id=\"violence-desecration\">none</content_attribute>\n\
                <content_attribute id=\"violence-slavery\">none</content_attribute>\n\
                <content_attribute id=\"violence-worship\">none</content_attribute>\n\
                <content_attribute id=\"drugs-alcohol\">none</content_attribute>\n\
                <content_attribute id=\"drugs-narcotics\">none</content_attribute>\n\
                <content_attribute id=\"drugs-tobacco\">none</content_attribute>\n\
                <content_attribute id=\"sex-nudity\">none</content_attribute>\n\
                <content_attribute id=\"sex-themes\">none</content_attribute>\n\
                <content_attribute id=\"language-profanity\">none</content_attribute>\n\
                <content_attribute id=\"language-humor\">none</content_attribute>\n\
                <content_attribute id=\"language-discrimination\">none</content_attribute>\n\
                <content_attribute id=\"social-chat\">none</content_attribute>\n\
                <content_attribute id=\"social-info\">none</content_attribute>\n\
                <content_attribute id=\"social-audio\">none</content_attribute>\n\
                <content_attribute id=\"social-location\">none</content_attribute>\n\
                <content_attribute id=\"social-contacts\">none</content_attribute>\n\
                <content_attribute id=\"money-purchasing\">none</content_attribute>\n\
                <content_attribute id=\"money-gambling\">none</content_attribute>\n\
              </content_rating>\n\
            </component>",
            self.project_name,
            self.project_name,
            self.project_name
        );
        
        fs::write(
            appdir.join("usr").join("share").join("metainfo").join(format!("{}.appdata.xml", self.project_name)),
            appstream_content
        )?;
        
        // Create professional AppRun script
        let apprun_content = format!(
            "#!/bin/bash\n\
            # Professional AppRun script for {}\n\
            # Generated by LOL PRO - Enterprise Edition\n\
            \n\
            cd \"${{APPDIR}}/usr/bin\"\n\
            \n\
            # Set professional environment variables\n\
            export LOL_PRO_BUILD_ID=\"{}\"\n\
            export LOL_PRO_TIMESTAMP=\"{}\"\n\
            export LOL_PRO_ENTERPRISE=true\n\
            \n\
            # Execute the consolidated application\n\
            exec \"${{APPDIR}}/usr/bin/{}.py\" \"$@\"\n",
            self.project_name,
            self.build_id,
            self.timestamp.format("%Y-%m-%d %H:%M:%S UTC"),
            self.project_name
        );
        
        let apprun_path = appdir.join("AppRun");
        fs::write(&apprun_path, apprun_content)?;
        
        // Make AppRun executable
        let mut perms = fs::metadata(&apprun_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&apprun_path, perms)?;
        
        Ok(())
    }

    fn generate_professional_icon(&self) -> Result<()> {
        let icon_path = self.output_dir
            .join("AppDir")
            .join("usr")
            .join("share")
            .join("icons")
            .join("hicolor")
            .join("256x256")
            .join("apps")
            .join(format!("{}.png", self.project_name));
        
        // Create a professional-looking icon with the project name
        let width = 256;
        let height = 256;
        let mut img = ImageBuffer::new(width, height);
        
        // Create a professional gradient background
        for (x, y, pixel) in img.enumerate_pixels_mut() {
            let r = ((x as f32 / width as f32) * 255.0) as u8;
            let g = ((y as f32 / height as f32) * 255.0) as u8;
            let b = 128;
            *pixel = Rgb([r, g, b]);
        }
        
        // Save the icon
        img.save(&icon_path)?;
        
        Ok(())
    }

    async fn create_professional_appimage(&self) -> Result<PathBuf> {
        let appdir = self.output_dir.join("AppDir");
        let appimage_path = self.output_dir.join(format!("{}-Pro.AppImage", self.project_name));
        
        // Check if appimagetool is available
        if Command::new("appimagetool").arg("--version").output().is_ok() {
            println!("üîß Using appimagetool for professional AppImage creation...");
            
            // Use appimagetool with professional options
            let output = Command::new("appimagetool")
                .arg("--no-appstream")
                .arg("--verbose")
                .arg(&appdir)
                .arg(&appimage_path)
                .output()
                .context("Failed to create professional AppImage with appimagetool")?;
            
            if !output.status.success() {
                return Err(anyhow::anyhow!(
                    "appimagetool failed: {}",
                    String::from_utf8_lossy(&output.stderr)
                ));
            }
            
            println!("‚úÖ Professional AppImage created with appimagetool");
        } else {
            // Fallback: create a professional tar.gz archive
            println!("‚ö†Ô∏è  appimagetool not found, creating professional archive instead");
            self.create_professional_fallback_archive(&appdir, &appimage_path)?;
        }
        
        Ok(appimage_path)
    }

    fn create_professional_fallback_archive(&self, appdir: &Path, output_path: &Path) -> Result<()> {
        let archive_path = output_path.with_extension("tar.gz");
        
        let output = Command::new("tar")
            .arg("-czf")
            .arg(&archive_path)
            .arg("--owner=0")
            .arg("--group=0")
            .arg("--numeric-owner")
            .arg("-C")
            .arg(appdir.parent().unwrap())
            .arg(appdir.file_name().unwrap())
            .output()
            .context("Failed to create professional tar archive")?;
        
        if !output.status.success() {
            return Err(anyhow::anyhow!(
                "tar failed: {}",
                String::from_utf8_lossy(&output.stderr)
            ));
        }
        
        println!("üì¶ Created professional archive: {}", archive_path.display());
        Ok(())
    }

    async fn generate_build_report(&self, appimage_path: &Path) -> Result<()> {
        let report_path = self.output_dir.join("build_report.json");
        
        let report = serde_json::json!({
            "project_name": self.project_name,
            "build_id": self.build_id,
            "timestamp": self.timestamp.to_rfc3339(),
            "source_files": {
                language.name(): {
                    "count": files.len(),
                    "files": files.iter().map(|f| {
                        let content = fs::read_to_string(f).unwrap_or_default();
                        serde_json::json!({
                            "path": f.to_string_lossy(),
                            "lines": content.lines().count(),
                            "size": content.len(),
                            "hash": self.calculate_file_hash(&content)
                        })
                    }).collect::<Vec<_>>()
                }
            },
            "output_path": appimage_path.to_string_lossy(),
            "enterprise_features": true,
            "build_tool": "LOL PRO - Enterprise Edition",
            "version": "1.0.0"
        });
        
        fs::write(&report_path, serde_json::to_string_pretty(&report)?)?;
        println!("üìä Build report generated: {}", report_path.display());
        
        Ok(())
    }

    pub fn get_professional_summary(&self) -> String {
        let mut summary = format!("üìã {} - Professional Source Files Summary\n", self.project_name);
        summary.push_str(&"=".repeat(60));
        summary.push_str(&format!("\nüîí Build ID: {}\n", self.build_id));
        summary.push_str(&format!("‚è∞ Timestamp: {}\n", self.timestamp.format("%Y-%m-%d %H:%M:%S UTC")));
        summary.push_str("üè¢ Enterprise Features: ACTIVATED\n");
        summary.push_str(&"=".repeat(60));
        
        for (language, files) in &self.source_files {
            summary.push_str(&format!("\nüîß {}: {} files\n", language.name(), files.len()));
            for file in files {
                if let Ok(content) = fs::read_to_string(file) {
                    let lines = content.lines().count();
                    let size = content.len();
                    let hash = self.calculate_file_hash(&content);
                    let filename = file.file_name().unwrap().to_string_lossy();
                    summary.push_str(&format!("  - {} ({} lines, {} bytes, hash: {})\n", 
                        filename, lines, size, hash));
                }
            }
        }
        
        summary.push_str(&format!("\nüìä Total Files: {}\n", 
            self.source_files.values().map(|v| v.len()).sum::<usize>()));
        summary.push_str("üöÄ Professional AppImage will include all source code and metadata\n");
        
        summary
    }
} 