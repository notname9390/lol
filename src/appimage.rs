use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::os::unix::fs::PermissionsExt;
use anyhow::{Context, Result};
use crate::language_support::Language;

pub struct AppImageBuilder {
    project_name: String,
    source_files: HashMap<Language, Vec<PathBuf>>,
    output_dir: PathBuf,
}

impl AppImageBuilder {
    pub fn new(project_name: String, source_files: HashMap<Language, Vec<PathBuf>>) -> Self {
        let output_dir = PathBuf::from(format!("./{}_appimage", project_name));
        Self {
            project_name,
            source_files,
            output_dir,
        }
    }

    pub fn build(&self) -> Result<PathBuf> {
        // Create output directory structure
        self.create_directory_structure()?;
        
        // Consolidate source files
        let consolidated_file = self.consolidate_source_files()?;
        
        // Create AppImage structure
        self.create_appimage_structure(&consolidated_file)?;
        
        // Create the AppImage
        let appimage_path = self.create_appimage()?;
        
        Ok(appimage_path)
    }

    fn create_directory_structure(&self) -> Result<()> {
        // Create main output directory
        fs::create_dir_all(&self.output_dir)?;
        
        // Create AppDir structure
        let appdir = self.output_dir.join("AppDir");
        fs::create_dir_all(&appdir)?;
        
        // Create standard AppImage directories
        fs::create_dir_all(appdir.join("usr").join("bin"))?;
        fs::create_dir_all(appdir.join("usr").join("share").join("applications"))?;
        fs::create_dir_all(appdir.join("usr").join("share").join("icons").join("hicolor").join("256x256").join("apps"))?;
        
        Ok(())
    }

    fn consolidate_source_files(&self) -> Result<PathBuf> {
        let consolidated_path = self.output_dir.join("AppDir").join("usr").join("bin").join(format!("{}.py", self.project_name));
        
        let mut consolidated_content = String::new();
        consolidated_content.push_str(&format!("# {} - Consolidated Source Code\n", self.project_name));
        consolidated_content.push_str("# Generated by lol - Multi-language Code Compiler\n\n");
        
        // Add Python shebang and imports
        consolidated_content.push_str("#!/usr/bin/env python3\n");
        consolidated_content.push_str("import os\nimport sys\nimport subprocess\nimport tempfile\n\n");
        
        // Add main function
        consolidated_content.push_str("def main():\n");
        consolidated_content.push_str(&format!("    print(f'ðŸš€ {} - Multi-language Project')\n", self.project_name));
        consolidated_content.push_str("    print('ðŸ“ Source files consolidated into this AppImage\\n')\n\n");
        
        // Add source code from each language
        for (language, files) in &self.source_files {
            consolidated_content.push_str(&format!("    # {} Source Files\n", language.name()));
            consolidated_content.push_str(&format!("    print('ðŸ“‹ {} files:')\n", language.name()));
            
            for file in files {
                if let Ok(content) = fs::read_to_string(file) {
                    let filename = file.file_name().unwrap().to_string_lossy();
                    consolidated_content.push_str(&format!("    print('  - {}')\n", filename));
                    
                    // Store the source code as a string in the consolidated file
                    consolidated_content.push_str(&format!("    {}_code = '''{}\n'''\n\n", 
                        filename.replace(".", "_").replace("-", "_"), content));
                }
            }
            consolidated_content.push_str("\n");
        }
        
        // Add execution logic
        consolidated_content.push_str("    # Execute the main source file\n");
        consolidated_content.push_str("    try:\n");
        consolidated_content.push_str("        # Try to run Python files first\n");
        consolidated_content.push_str("        python_files = [f for f in os.listdir('.') if f.endswith('.py')]\n");
        consolidated_content.push_str("        if python_files:\n");
        consolidated_content.push_str("            main_file = python_files[0]\n");
        consolidated_content.push_str("            print(f'ðŸ Running {main_file}...')\n");
        consolidated_content.push_str("            subprocess.run([sys.executable, main_file])\n");
        consolidated_content.push_str("        else:\n");
        consolidated_content.push_str("            print('No Python files found to execute')\n");
        consolidated_content.push_str("    except Exception as e:\n");
        consolidated_content.push_str("        print(f'Error executing project: {e}')\n");
        consolidated_content.push_str("        print('You can extract and compile the source files manually')\n\n");
        
        consolidated_content.push_str("if __name__ == '__main__':\n");
        consolidated_content.push_str("    main()\n");
        
        fs::write(&consolidated_path, consolidated_content)?;
        
        // Make it executable
        let mut perms = fs::metadata(&consolidated_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&consolidated_path, perms)?;
        
        Ok(consolidated_path)
    }

    fn create_appimage_structure(&self, _consolidated_file: &Path) -> Result<()> {
        let appdir = self.output_dir.join("AppDir");
        
        // Create desktop entry
        let desktop_content = format!(
            "[Desktop Entry]\n\
            Name={}\n\
            Comment=Multi-language project generated by lol\n\
            Exec={}\n\
            Icon={}\n\
            Terminal=true\n\
            Type=Application\n\
            Categories=Development;\n",
            self.project_name,
            format!("{}.py", self.project_name),
            self.project_name
        );
        
        fs::write(
            appdir.join("usr").join("share").join("applications").join(format!("{}.desktop", self.project_name)),
            desktop_content
        )?;
        
        // Create a simple icon (placeholder)
        self.create_placeholder_icon()?;
        
        // Create AppRun script
        let apprun_content = format!(
            "#!/bin/bash\n\
            cd \"${{APPDIR}}/usr/bin\"\n\
            exec \"${{APPDIR}}/usr/bin/{}.py\" \"$@\"\n",
            self.project_name
        );
        
        let apprun_path = appdir.join("AppRun");
        fs::write(&apprun_path, apprun_content)?;
        
        // Make AppRun executable
        let mut perms = fs::metadata(&apprun_path)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&apprun_path, perms)?;
        
        Ok(())
    }

    fn create_placeholder_icon(&self) -> Result<()> {
        // Create a simple text-based icon as placeholder
        let icon_content = format!(
            "{}",
            self.project_name.chars().next().unwrap_or('L')
        );
        
        let icon_path = self.output_dir
            .join("AppDir")
            .join("usr")
            .join("share")
            .join("icons")
            .join("hicolor")
            .join("256x256")
            .join("apps")
            .join(format!("{}.png", self.project_name));
        
        // For now, just create a text file as placeholder
        // In a real implementation, you'd generate a proper PNG icon
        fs::write(icon_path.with_extension("txt"), icon_content)?;
        
        Ok(())
    }

    fn create_appimage(&self) -> Result<PathBuf> {
        let appdir = self.output_dir.join("AppDir");
        let appimage_path = self.output_dir.join(format!("{}.AppImage", self.project_name));
        
        // Check if appimagetool is available
        if Command::new("appimagetool").arg("--version").output().is_ok() {
            // Use appimagetool if available
            let output = Command::new("appimagetool")
                .arg("--no-appstream")
                .arg(&appdir)
                .arg(&appimage_path)
                .output()
                .context("Failed to create AppImage with appimagetool")?;
            
            if !output.status.success() {
                return Err(anyhow::anyhow!(
                    "appimagetool failed: {}",
                    String::from_utf8_lossy(&output.stderr)
                ));
            }
        } else {
            // Fallback: create a simple tar.gz archive
            println!("âš ï¸  appimagetool not found, creating archive instead");
            self.create_fallback_archive(&appdir, &appimage_path)?;
        }
        
        Ok(appimage_path)
    }

    fn create_fallback_archive(&self, appdir: &Path, output_path: &Path) -> Result<()> {
        let archive_path = output_path.with_extension("tar.gz");
        
        let output = Command::new("tar")
            .arg("-czf")
            .arg(&archive_path)
            .arg("-C")
            .arg(appdir.parent().unwrap())
            .arg(appdir.file_name().unwrap())
            .output()
            .context("Failed to create tar archive")?;
        
        if !output.status.success() {
            return Err(anyhow::anyhow!(
                "tar failed: {}",
                String::from_utf8_lossy(&output.stderr)
            ));
        }
        
        println!("ðŸ“¦ Created archive: {}", archive_path.display());
        Ok(())
    }

    pub fn get_source_summary(&self) -> String {
        let mut summary = format!("ðŸ“‹ {} - Source Files Summary\n", self.project_name);
        summary.push_str(&"=".repeat(50));
        summary.push('\n');
        
        for (language, files) in &self.source_files {
            summary.push_str(&format!("\nðŸ”§ {}: {} files\n", language.name(), files.len()));
            for file in files {
                if let Ok(content) = fs::read_to_string(file) {
                    let lines = content.lines().count();
                    let filename = file.file_name().unwrap().to_string_lossy();
                    summary.push_str(&format!("  - {} ({} lines)\n", filename, lines));
                }
            }
        }
        
        summary
    }
} 